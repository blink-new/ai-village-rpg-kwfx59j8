import { Player, InventoryItem, BuildingStructure } from '../types/game';\nimport { WorldTile } from '../types/world';\n\nexport interface BuildingBlueprint {\n  id: string;\n  name: string;\n  category: 'residential' | 'defensive' | 'production' | 'utility' | 'decorative' | 'magical';\n  type: 'house' | 'workshop' | 'farm' | 'mine' | 'tower' | 'wall' | 'gate' | 'storage' | 'forge' | 'enchanting_table' | 'alchemy_lab' | 'library' | 'temple';\n  size: { width: number; height: number };\n  requirements: {\n    materials: { itemId: string; quantity: number }[];\n    level: number;\n    skills: Record<string, number>;\n    terrain: string[]; // Allowed terrain types\n    clearance: number; // Required empty space around structure\n  };\n  stats: {\n    health: number;\n    defense: number;\n    capacity?: number;\n    efficiency?: number;\n    range?: number;\n  };\n  functionality: {\n    storage?: { capacity: number; types: string[] };\n    production?: {\n      input: { itemId: string; quantity: number }[];\n      output: { itemId: string; quantity: number }[];\n      rate: number; // Items per hour\n      workerSlots: number;\n    };\n    defense?: {\n      damage: number;\n      range: number;\n      attackSpeed: number;\n      ammunition?: string;\n    };\n    utility?: {\n      effect: string;\n      radius: number;\n      bonus: Record<string, number>;\n    };\n  };\n  upgrades: {\n    level: number;\n    materials: { itemId: string; quantity: number }[];\n    improvements: Record<string, number>;\n  }[];\n  description: string;\n  lore: string;\n}\n\nexport interface BuildingProject {\n  id: string;\n  blueprintId: string;\n  position: { x: number; y: number };\n  progress: number; // 0-100\n  materialsDeposited: { itemId: string; quantity: number }[];\n  workersAssigned: string[];\n  startTime: number;\n  estimatedCompletion: number;\n  paused: boolean;\n}\n\nexport interface BuildingWorker {\n  id: string;\n  name: string;\n  type: 'builder' | 'crafter' | 'farmer' | 'miner' | 'guard' | 'researcher';\n  level: number;\n  skills: Record<string, number>;\n  efficiency: number;\n  wage: number; // Gold per hour\n  currentTask?: string;\n  assignedBuilding?: string;\n  happiness: number;\n  loyalty: number;\n}\n\nexport interface Settlement {\n  id: string;\n  name: string;\n  owner: string;\n  center: { x: number; y: number };\n  radius: number;\n  buildings: Map<string, BuildingStructure>;\n  population: number;\n  happiness: number;\n  defense: number;\n  resources: Map<string, number>;\n  workers: Map<string, BuildingWorker>;\n  reputation: number;\n  established: number;\n  lastUpdate: number;\n}\n\nexport class EpicBuildingSystem {\n  private blueprints: Map<string, BuildingBlueprint> = new Map();\n  private activeProjects: Map<string, BuildingProject> = new Map();\n  private settlements: Map<string, Settlement> = new Map();\n  private workers: Map<string, BuildingWorker> = new Map();\n  \n  constructor() {\n    this.initializeBlueprints();\n    this.initializeWorkerTypes();\n  }\n  \n  private initializeBlueprints(): void {\n    // Basic Residential Buildings\n    this.addBlueprint({\n      id: 'wooden_hut',\n      name: 'Wooden Hut',\n      category: 'residential',\n      type: 'house',\n      size: { width: 3, height: 3 },\n      requirements: {\n        materials: [\n          { itemId: 'wood', quantity: 20 },\n          { itemId: 'stone', quantity: 10 },\n          { itemId: 'rope', quantity: 5 }\n        ],\n        level: 1,\n        skills: { crafting: 1 },\n        terrain: ['grassland', 'forest', 'plains'],\n        clearance: 1\n      },\n      stats: {\n        health: 200,\n        defense: 10,\n        capacity: 2\n      },\n      functionality: {\n        storage: { capacity: 100, types: ['all'] }\n      },\n      upgrades: [\n        {\n          level: 2,\n          materials: [{ itemId: 'iron_ingot', quantity: 5 }, { itemId: 'glass', quantity: 3 }],\n          improvements: { health: 50, capacity: 1 }\n        }\n      ],\n      description: 'A simple wooden dwelling for basic shelter.',\n      lore: 'Every great settlement starts with humble beginnings.'\n    });\n    \n    // Epic Fortress\n    this.addBlueprint({\n      id: 'legendary_fortress',\n      name: 'Legendary Fortress',\n      category: 'defensive',\n      type: 'tower',\n      size: { width: 10, height: 10 },\n      requirements: {\n        materials: [\n          { itemId: 'mithril_ingot', quantity: 100 },\n          { itemId: 'dragon_stone', quantity: 50 },\n          { itemId: 'enchanted_crystal', quantity: 25 },\n          { itemId: 'ancient_rune', quantity: 10 }\n        ],\n        level: 50,\n        skills: { crafting: 80, magic: 60 },\n        terrain: ['mountains', 'hills'],\n        clearance: 5\n      },\n      stats: {\n        health: 10000,\n        defense: 500,\n        range: 200\n      },\n      functionality: {\n        defense: {\n          damage: 300,\n          range: 200,\n          attackSpeed: 2,\n          ammunition: 'magic_bolt'\n        },\n        utility: {\n          effect: 'area_protection',\n          radius: 100,\n          bonus: { defense: 50, regeneration: 10 }\n        }\n      },\n      upgrades: [\n        {\n          level: 2,\n          materials: [{ itemId: 'divine_essence', quantity: 10 }],\n          improvements: { health: 5000, defense: 200, range: 50 }\n        }\n      ],\n      description: 'An impregnable fortress that can withstand the mightiest of sieges.',\n      lore: 'Built by legendary architects, this fortress has never fallen to any army.'\n    });\n    \n    // Magical Workshop\n    this.addBlueprint({\n      id: 'arcane_workshop',\n      name: 'Arcane Workshop',\n      category: 'production',\n      type: 'workshop',\n      size: { width: 6, height: 6 },\n      requirements: {\n        materials: [\n          { itemId: 'crystal_shard', quantity: 30 },\n          { itemId: 'magical_wood', quantity: 40 },\n          { itemId: 'silver_ingot', quantity: 20 },\n          { itemId: 'spell_scroll', quantity: 5 }\n        ],\n        level: 25,\n        skills: { magic: 40, crafting: 30 },\n        terrain: ['forest', 'mountains'],\n        clearance: 2\n      },\n      stats: {\n        health: 800,\n        defense: 30,\n        efficiency: 150\n      },\n      functionality: {\n        production: {\n          input: [{ itemId: 'raw_crystal', quantity: 1 }, { itemId: 'mana_essence', quantity: 2 }],\n          output: [{ itemId: 'enchanted_crystal', quantity: 1 }],\n          rate: 4, // 4 per hour\n          workerSlots: 2\n        }\n      },\n      upgrades: [\n        {\n          level: 2,\n          materials: [{ itemId: 'master_crystal', quantity: 5 }],\n          improvements: { efficiency: 50, rate: 2 }\n        }\n      ],\n      description: 'A workshop infused with magical energy for creating enchanted items.',\n      lore: 'Where mortal craftsmanship meets divine magic.'\n    });\n    \n    // Dragon Lair (Ultimate Building)\n    this.addBlueprint({\n      id: 'dragon_lair',\n      name: 'Ancient Dragon Lair',\n      category: 'magical',\n      type: 'temple',\n      size: { width: 15, height: 15 },\n      requirements: {\n        materials: [\n          { itemId: 'dragon_scale', quantity: 200 },\n          { itemId: 'volcanic_stone', quantity: 500 },\n          { itemId: 'dragon_heart', quantity: 1 },\n          { itemId: 'legendary_gem', quantity: 50 }\n        ],\n        level: 80,\n        skills: { magic: 100, crafting: 90 },\n        terrain: ['mountains', 'volcano'],\n        clearance: 10\n      },\n      stats: {\n        health: 50000,\n        defense: 1000,\n        capacity: 1000\n      },\n      functionality: {\n        storage: { capacity: 10000, types: ['legendary', 'artifact', 'treasure'] },\n        utility: {\n          effect: 'dragon_blessing',\n          radius: 500,\n          bonus: { experience: 100, magic: 50, luck: 25 }\n        },\n        defense: {\n          damage: 1000,\n          range: 300,\n          attackSpeed: 1,\n          ammunition: 'dragon_breath'\n        }\n      },\n      upgrades: [],\n      description: 'The ultimate dwelling for those who have conquered dragons.',\n      lore: 'Only the most legendary heroes dare to claim a dragon\\'s lair as their own.'\n    });\n  }\n  \n  private initializeWorkerTypes(): void {\n    // Initialize different types of workers with their specializations\n  }\n  \n  private addBlueprint(blueprint: BuildingBlueprint): void {\n    this.blueprints.set(blueprint.id, blueprint);\n  }\n  \n  // Building placement and validation\n  canPlaceBuilding(blueprintId: string, x: number, y: number, worldTiles: (x: number, y: number) => WorldTile): {\n    canPlace: boolean;\n    reasons: string[];\n  } {\n    const blueprint = this.blueprints.get(blueprintId);\n    if (!blueprint) {\n      return { canPlace: false, reasons: ['Blueprint not found'] };\n    }\n    \n    const reasons: string[] = [];\n    \n    // Check terrain compatibility\n    for (let dx = 0; dx < blueprint.size.width; dx++) {\n      for (let dy = 0; dy < blueprint.size.height; dy++) {\n        const tile = worldTiles(x + dx, y + dy);\n        \n        if (!blueprint.requirements.terrain.includes(tile.biome)) {\n          reasons.push(`Incompatible terrain: ${tile.biome}`);\n        }\n        \n        if (tile.solid) {\n          reasons.push('Cannot build on solid terrain');\n        }\n        \n        if (tile.height < 0.2) {\n          reasons.push('Cannot build on water');\n        }\n      }\n    }\n    \n    // Check clearance\n    const clearance = blueprint.requirements.clearance;\n    for (let dx = -clearance; dx < blueprint.size.width + clearance; dx++) {\n      for (let dy = -clearance; dy < blueprint.size.height + clearance; dy++) {\n        if (dx >= 0 && dx < blueprint.size.width && dy >= 0 && dy < blueprint.size.height) {\n          continue; // Skip the building area itself\n        }\n        \n        // Check for existing buildings in clearance area\n        if (this.isBuildingAt(x + dx, y + dy)) {\n          reasons.push('Not enough clearance from existing buildings');\n        }\n      }\n    }\n    \n    return {\n      canPlace: reasons.length === 0,\n      reasons\n    };\n  }\n  \n  private isBuildingAt(x: number, y: number): boolean {\n    // Check all settlements for buildings at this position\n    for (const settlement of this.settlements.values()) {\n      for (const building of settlement.buildings.values()) {\n        if (x >= building.position.x && x < building.position.x + building.size.width &&\n            y >= building.position.y && y < building.position.y + building.size.height) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  \n  // Building construction\n  startBuildingProject(player: Player, blueprintId: string, x: number, y: number): {\n    success: boolean;\n    message: string;\n    projectId?: string;\n  } {\n    const blueprint = this.blueprints.get(blueprintId);\n    if (!blueprint) {\n      return { success: false, message: 'Blueprint not found' };\n    }\n    \n    // Check player requirements\n    if (player.level < blueprint.requirements.level) {\n      return { success: false, message: `Requires level ${blueprint.requirements.level}` };\n    }\n    \n    // Check skill requirements\n    for (const [skill, required] of Object.entries(blueprint.requirements.skills)) {\n      const playerSkill = player.skills[skill as keyof typeof player.skills] || 0;\n      if (playerSkill < required) {\n        return { success: false, message: `Requires ${skill} level ${required}` };\n      }\n    }\n    \n    // Check materials\n    for (const material of blueprint.requirements.materials) {\n      const playerItem = player.inventory.find(item => item.id === material.itemId);\n      if (!playerItem || playerItem.quantity < material.quantity) {\n        return { success: false, message: `Requires ${material.quantity} ${material.itemId}` };\n      }\n    }\n    \n    // Create building project\n    const projectId = `project_${Date.now()}_${Math.random()}`;\n    const project: BuildingProject = {\n      id: projectId,\n      blueprintId,\n      position: { x, y },\n      progress: 0,\n      materialsDeposited: [],\n      workersAssigned: [],\n      startTime: Date.now(),\n      estimatedCompletion: Date.now() + this.calculateBuildTime(blueprint),\n      paused: false\n    };\n    \n    this.activeProjects.set(projectId, project);\n    \n    return {\n      success: true,\n      message: `Started building ${blueprint.name}`,\n      projectId\n    };\n  }\n  \n  private calculateBuildTime(blueprint: BuildingBlueprint): number {\n    // Base time calculation based on building complexity\n    const baseTime = blueprint.size.width * blueprint.size.height * 1000; // 1 second per tile\n    const complexityMultiplier = this.getComplexityMultiplier(blueprint.category);\n    const materialComplexity = blueprint.requirements.materials.reduce((sum, mat) => sum + mat.quantity, 0);\n    \n    return baseTime * complexityMultiplier * (1 + materialComplexity / 100);\n  }\n  \n  private getComplexityMultiplier(category: string): number {\n    const multipliers = {\n      residential: 1.0,\n      production: 1.5,\n      defensive: 2.0,\n      utility: 1.2,\n      decorative: 0.8,\n      magical: 3.0\n    };\n    \n    return multipliers[category as keyof typeof multipliers] || 1.0;\n  }\n  \n  // Material management\n  depositMaterials(projectId: string, materials: { itemId: string; quantity: number }[]): {\n    success: boolean;\n    message: string;\n  } {\n    const project = this.activeProjects.get(projectId);\n    if (!project) {\n      return { success: false, message: 'Project not found' };\n    }\n    \n    const blueprint = this.blueprints.get(project.blueprintId);\n    if (!blueprint) {\n      return { success: false, message: 'Blueprint not found' };\n    }\n    \n    // Add materials to project\n    for (const material of materials) {\n      const existing = project.materialsDeposited.find(m => m.itemId === material.itemId);\n      if (existing) {\n        existing.quantity += material.quantity;\n      } else {\n        project.materialsDeposited.push({ ...material });\n      }\n    }\n    \n    // Check if all materials are available\n    const allMaterialsAvailable = blueprint.requirements.materials.every(required => {\n      const deposited = project.materialsDeposited.find(m => m.itemId === required.itemId);\n      return deposited && deposited.quantity >= required.quantity;\n    });\n    \n    if (allMaterialsAvailable && project.progress === 0) {\n      // Start construction\n      project.progress = 1;\n    }\n    \n    return { success: true, message: 'Materials deposited successfully' };\n  }\n  \n  // Worker management\n  assignWorker(projectId: string, workerId: string): {\n    success: boolean;\n    message: string;\n  } {\n    const project = this.activeProjects.get(projectId);\n    const worker = this.workers.get(workerId);\n    \n    if (!project) {\n      return { success: false, message: 'Project not found' };\n    }\n    \n    if (!worker) {\n      return { success: false, message: 'Worker not found' };\n    }\n    \n    if (worker.currentTask) {\n      return { success: false, message: 'Worker is already assigned to another task' };\n    }\n    \n    // Assign worker\n    project.workersAssigned.push(workerId);\n    worker.currentTask = projectId;\n    \n    // Recalculate completion time based on worker efficiency\n    this.updateProjectCompletion(project);\n    \n    return { success: true, message: `Worker ${worker.name} assigned to project` };\n  }\n  \n  private updateProjectCompletion(project: BuildingProject): void {\n    const blueprint = this.blueprints.get(project.blueprintId);\n    if (!blueprint) return;\n    \n    // Calculate total worker efficiency\n    let totalEfficiency = 1; // Base efficiency\n    for (const workerId of project.workersAssigned) {\n      const worker = this.workers.get(workerId);\n      if (worker) {\n        totalEfficiency += worker.efficiency;\n      }\n    }\n    \n    // Adjust completion time\n    const baseTime = this.calculateBuildTime(blueprint);\n    const adjustedTime = baseTime / totalEfficiency;\n    project.estimatedCompletion = project.startTime + adjustedTime;\n  }\n  \n  // Building completion and management\n  updateProjects(deltaTime: number): void {\n    const now = Date.now();\n    \n    for (const [projectId, project] of this.activeProjects.entries()) {\n      if (project.paused) continue;\n      \n      // Update progress\n      if (project.progress > 0 && project.progress < 100) {\n        const timeElapsed = now - project.startTime;\n        const totalTime = project.estimatedCompletion - project.startTime;\n        project.progress = Math.min(100, (timeElapsed / totalTime) * 100);\n        \n        // Complete building\n        if (project.progress >= 100) {\n          this.completeBuilding(projectId);\n        }\n      }\n    }\n  }\n  \n  private completeBuilding(projectId: string): void {\n    const project = this.activeProjects.get(projectId);\n    if (!project) return;\n    \n    const blueprint = this.blueprints.get(project.blueprintId);\n    if (!blueprint) return;\n    \n    // Create the actual building\n    const building: BuildingStructure = {\n      id: `building_${Date.now()}_${Math.random()}`,\n      type: blueprint.type,\n      position: project.position,\n      size: blueprint.size,\n      level: 1,\n      health: blueprint.stats.health,\n      maxHealth: blueprint.stats.health,\n      functionality: blueprint.functionality,\n      upgradeCosts: blueprint.upgrades.reduce((costs, upgrade) => {\n        costs[upgrade.level] = upgrade.materials;\n        return costs;\n      }, {} as Record<number, InventoryItem[]>),\n      workers: []\n    };\n    \n    // Add to settlement or create new settlement\n    this.addBuildingToSettlement(building, project.position);\n    \n    // Clean up project\n    this.activeProjects.delete(projectId);\n    \n    // Free up workers\n    for (const workerId of project.workersAssigned) {\n      const worker = this.workers.get(workerId);\n      if (worker) {\n        worker.currentTask = undefined;\n      }\n    }\n    \n    console.log(`Building completed: ${blueprint.name}`);\n  }\n  \n  private addBuildingToSettlement(building: BuildingStructure, position: { x: number; y: number }): void {\n    // Find existing settlement or create new one\n    let targetSettlement: Settlement | null = null;\n    \n    for (const settlement of this.settlements.values()) {\n      const distance = Math.sqrt(\n        Math.pow(settlement.center.x - position.x, 2) + \n        Math.pow(settlement.center.y - position.y, 2)\n      );\n      \n      if (distance <= settlement.radius) {\n        targetSettlement = settlement;\n        break;\n      }\n    }\n    \n    if (!targetSettlement) {\n      // Create new settlement\n      const settlementId = `settlement_${Date.now()}`;\n      targetSettlement = {\n        id: settlementId,\n        name: 'New Settlement',\n        owner: 'player', // Should be actual player ID\n        center: position,\n        radius: 100,\n        buildings: new Map(),\n        population: 0,\n        happiness: 50,\n        defense: 0,\n        resources: new Map(),\n        workers: new Map(),\n        reputation: 0,\n        established: Date.now(),\n        lastUpdate: Date.now()\n      };\n      \n      this.settlements.set(settlementId, targetSettlement);\n    }\n    \n    // Add building to settlement\n    targetSettlement.buildings.set(building.id, building);\n    \n    // Update settlement stats\n    this.updateSettlementStats(targetSettlement);\n  }\n  \n  private updateSettlementStats(settlement: Settlement): void {\n    // Calculate total defense\n    settlement.defense = 0;\n    settlement.population = 0;\n    \n    for (const building of settlement.buildings.values()) {\n      if (building.functionality.defense) {\n        settlement.defense += building.functionality.defense.damage;\n      }\n      \n      if (building.type === 'house') {\n        settlement.population += building.functionality.storage?.capacity || 0;\n      }\n    }\n    \n    settlement.lastUpdate = Date.now();\n  }\n  \n  // Building upgrades\n  upgradeBuilding(buildingId: string, targetLevel: number, materials: { itemId: string; quantity: number }[]): {\n    success: boolean;\n    message: string;\n  } {\n    // Find building in settlements\n    let building: BuildingStructure | null = null;\n    let blueprint: BuildingBlueprint | null = null;\n    \n    for (const settlement of this.settlements.values()) {\n      const foundBuilding = settlement.buildings.get(buildingId);\n      if (foundBuilding) {\n        building = foundBuilding;\n        // Find blueprint by building type (simplified)\n        for (const bp of this.blueprints.values()) {\n          if (bp.type === building.type) {\n            blueprint = bp;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    \n    if (!building || !blueprint) {\n      return { success: false, message: 'Building not found' };\n    }\n    \n    // Find upgrade requirements\n    const upgrade = blueprint.upgrades.find(u => u.level === targetLevel);\n    if (!upgrade) {\n      return { success: false, message: 'Upgrade not available' };\n    }\n    \n    // Check materials\n    for (const required of upgrade.materials) {\n      const provided = materials.find(m => m.itemId === required.itemId);\n      if (!provided || provided.quantity < required.quantity) {\n        return { success: false, message: `Requires ${required.quantity} ${required.itemId}` };\n      }\n    }\n    \n    // Apply upgrade\n    building.level = targetLevel;\n    for (const [stat, improvement] of Object.entries(upgrade.improvements)) {\n      if (stat === 'health') {\n        building.maxHealth += improvement;\n        building.health += improvement;\n      }\n      // Apply other improvements\n    }\n    \n    return { success: true, message: `Building upgraded to level ${targetLevel}` };\n  }\n  \n  // Public API\n  getBlueprints(): BuildingBlueprint[] {\n    return Array.from(this.blueprints.values());\n  }\n  \n  getBlueprint(id: string): BuildingBlueprint | undefined {\n    return this.blueprints.get(id);\n  }\n  \n  getActiveProjects(): BuildingProject[] {\n    return Array.from(this.activeProjects.values());\n  }\n  \n  getProject(id: string): BuildingProject | undefined {\n    return this.activeProjects.get(id);\n  }\n  \n  getSettlements(): Settlement[] {\n    return Array.from(this.settlements.values());\n  }\n  \n  getSettlement(id: string): Settlement | undefined {\n    return this.settlements.get(id);\n  }\n  \n  getBuildingsInArea(x: number, y: number, radius: number): BuildingStructure[] {\n    const buildings: BuildingStructure[] = [];\n    \n    for (const settlement of this.settlements.values()) {\n      for (const building of settlement.buildings.values()) {\n        const distance = Math.sqrt(\n          Math.pow(building.position.x - x, 2) + \n          Math.pow(building.position.y - y, 2)\n        );\n        \n        if (distance <= radius) {\n          buildings.push(building);\n        }\n      }\n    }\n    \n    return buildings;\n  }\n  \n  // Settlement management\n  createSettlement(name: string, owner: string, center: { x: number; y: number }): string {\n    const settlementId = `settlement_${Date.now()}_${Math.random()}`;\n    const settlement: Settlement = {\n      id: settlementId,\n      name,\n      owner,\n      center,\n      radius: 100,\n      buildings: new Map(),\n      population: 0,\n      happiness: 50,\n      defense: 0,\n      resources: new Map(),\n      workers: new Map(),\n      reputation: 0,\n      established: Date.now(),\n      lastUpdate: Date.now()\n    };\n    \n    this.settlements.set(settlementId, settlement);\n    return settlementId;\n  }\n  \n  // Resource management for settlements\n  addResourceToSettlement(settlementId: string, resourceId: string, quantity: number): void {\n    const settlement = this.settlements.get(settlementId);\n    if (!settlement) return;\n    \n    const current = settlement.resources.get(resourceId) || 0;\n    settlement.resources.set(resourceId, current + quantity);\n  }\n  \n  consumeResourceFromSettlement(settlementId: string, resourceId: string, quantity: number): boolean {\n    const settlement = this.settlements.get(settlementId);\n    if (!settlement) return false;\n    \n    const current = settlement.resources.get(resourceId) || 0;\n    if (current < quantity) return false;\n    \n    settlement.resources.set(resourceId, current - quantity);\n    return true;\n  }\n  \n  // Update system\n  update(deltaTime: number): void {\n    this.updateProjects(deltaTime);\n    this.updateSettlements(deltaTime);\n    this.updateWorkers(deltaTime);\n  }\n  \n  private updateSettlements(deltaTime: number): void {\n    for (const settlement of this.settlements.values()) {\n      // Update production buildings\n      for (const building of settlement.buildings.values()) {\n        if (building.functionality.production) {\n          this.updateBuildingProduction(settlement, building, deltaTime);\n        }\n      }\n    }\n  }\n  \n  private updateBuildingProduction(settlement: Settlement, building: BuildingStructure, deltaTime: number): void {\n    const production = building.functionality.production;\n    if (!production) return;\n    \n    // Check if building has workers\n    if (building.workers && building.workers.length === 0) return;\n    \n    // Calculate production rate (simplified)\n    const hourlyRate = production.rate;\n    const productionThisTick = (hourlyRate * deltaTime) / (1000 * 60 * 60); // Convert to per-millisecond\n    \n    // Check input materials\n    let canProduce = true;\n    for (const input of production.input) {\n      const available = settlement.resources.get(input.itemId) || 0;\n      if (available < input.quantity * productionThisTick) {\n        canProduce = false;\n        break;\n      }\n    }\n    \n    if (canProduce) {\n      // Consume inputs\n      for (const input of production.input) {\n        const consumed = input.quantity * productionThisTick;\n        this.consumeResourceFromSettlement(settlement.id, input.itemId, consumed);\n      }\n      \n      // Produce outputs\n      for (const output of production.output) {\n        const produced = output.quantity * productionThisTick;\n        this.addResourceToSettlement(settlement.id, output.itemId, produced);\n      }\n    }\n  }\n  \n  private updateWorkers(deltaTime: number): void {\n    for (const worker of this.workers.values()) {\n      // Update worker happiness, loyalty, etc.\n      // Handle worker wages\n      // Process worker tasks\n    }\n  }\n}
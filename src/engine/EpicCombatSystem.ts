import { Player, Enemy, CombatAction, CombatResult, StatusEffect, Spell } from '../types/game';\nimport { Entity } from '../types/world';\n\nexport interface BossPhase {\n  id: string;\n  name: string;\n  healthThreshold: number; // 0.0 to 1.0\n  abilities: BossAbility[];\n  mechanics: BossMechanic[];\n  enrageTimer?: number;\n  phaseTransition?: {\n    animation: string;\n    invulnerable: boolean;\n    duration: number;\n    effects: StatusEffect[];\n  };\n}\n\nexport interface BossAbility {\n  id: string;\n  name: string;\n  type: 'attack' | 'spell' | 'summon' | 'environmental' | 'ultimate';\n  damage: number;\n  range: number;\n  cooldown: number;\n  castTime: number;\n  manaCost: number;\n  effects: StatusEffect[];\n  targeting: 'single' | 'aoe' | 'line' | 'cone' | 'random';\n  animation: string;\n  soundEffect: string;\n  description: string;\n  telegraphTime: number; // Warning time before ability hits\n  interruptible: boolean;\n}\n\nexport interface BossMechanic {\n  id: string;\n  type: 'enrage' | 'shield' | 'heal' | 'summon_adds' | 'environmental_hazard' | 'phase_transition';\n  trigger: 'health' | 'time' | 'ability_use' | 'player_action';\n  triggerValue: number;\n  effect: any;\n  duration?: number;\n  description: string;\n}\n\nexport interface CombatEvent {\n  id: string;\n  type: 'damage' | 'heal' | 'status_applied' | 'status_removed' | 'ability_used' | 'phase_change' | 'death';\n  timestamp: number;\n  source: string;\n  target: string;\n  value: number;\n  data: any;\n}\n\nexport interface DamageCalculation {\n  baseDamage: number;\n  criticalHit: boolean;\n  criticalMultiplier: number;\n  damageReduction: number;\n  finalDamage: number;\n  damageType: 'physical' | 'magical' | 'fire' | 'ice' | 'lightning' | 'poison' | 'holy' | 'dark';\n  resistances: Record<string, number>;\n  vulnerabilities: Record<string, number>;\n}\n\nexport class EpicCombatSystem {\n  private combatants: Map<string, CombatEntity> = new Map();\n  private statusEffects: Map<string, StatusEffect[]> = new Map();\n  private combatEvents: CombatEvent[] = [];\n  private activeBosses: Map<string, BossData> = new Map();\n  private combatZones: Map<string, CombatZone> = new Map();\n  \n  // Combat state\n  private combatActive = false;\n  private turnOrder: string[] = [];\n  private currentTurn = 0;\n  private combatTimer = 0;\n  \n  // Damage calculation settings\n  private damageVariance = 0.1; // ¬±10% damage variance\n  private criticalChance = 0.05; // Base 5% crit chance\n  private criticalMultiplier = 2.0; // 2x damage on crit\n  \n  constructor() {\n    this.initializeCombatSystem();\n  }\n  \n  private initializeCombatSystem(): void {\n    // Initialize legendary boss encounters\n    this.initializeLegendaryBosses();\n    \n    // Set up combat zones\n    this.initializeCombatZones();\n  }\n  \n  private initializeLegendaryBosses(): void {\n    // Ancient Dragon Boss\n    const dragonBoss: BossData = {\n      id: 'ancient_dragon',\n      name: 'Pyraxis the Ancient',\n      level: 50,\n      maxHealth: 10000,\n      currentHealth: 10000,\n      phases: [\n        {\n          id: 'phase1',\n          name: 'Awakening Fury',\n          healthThreshold: 1.0,\n          abilities: [\n            {\n              id: 'flame_breath',\n              name: 'Devastating Flame Breath',\n              type: 'attack',\n              damage: 300,\n              range: 200,\n              cooldown: 8000,\n              castTime: 2000,\n              manaCost: 0,\n              effects: [{\n                id: 'burning',\n                name: 'Burning',\n                type: 'dot',\n                icon: 'üî•',\n                description: 'Taking fire damage over time',\n                duration: 5000,\n                intensity: 50,\n                tickDamage: 50,\n                effects: [],\n                stackable: true,\n                maxStacks: 3\n              }],\n              targeting: 'cone',\n              animation: 'flame_breath',\n              soundEffect: 'dragon_roar',\n              description: 'A devastating cone of dragon fire',\n              telegraphTime: 1500,\n              interruptible: false\n            },\n            {\n              id: 'tail_swipe',\n              name: 'Crushing Tail Swipe',\n              type: 'attack',\n              damage: 250,\n              range: 150,\n              cooldown: 5000,\n              castTime: 1000,\n              manaCost: 0,\n              effects: [{\n                id: 'knockback',\n                name: 'Knockback',\n                type: 'debuff',\n                icon: 'üí®',\n                description: 'Knocked backwards',\n                duration: 1000,\n                intensity: 1,\n                effects: [],\n                stackable: false\n              }],\n              targeting: 'aoe',\n              animation: 'tail_swipe',\n              soundEffect: 'heavy_impact',\n              description: 'A powerful tail attack that knocks back enemies',\n              telegraphTime: 800,\n              interruptible: false\n            }\n          ],\n          mechanics: [\n            {\n              id: 'fire_immunity',\n              type: 'shield',\n              trigger: 'health',\n              triggerValue: 0.8,\n              effect: { immunities: ['fire'] },\n              description: 'Becomes immune to fire damage'\n            }\n          ]\n        },\n        {\n          id: 'phase2',\n          name: 'Infernal Rage',\n          healthThreshold: 0.6,\n          abilities: [\n            {\n              id: 'meteor_storm',\n              name: 'Apocalyptic Meteor Storm',\n              type: 'ultimate',\n              damage: 500,\n              range: 300,\n              cooldown: 15000,\n              castTime: 4000,\n              manaCost: 0,\n              effects: [{\n                id: 'stunned',\n                name: 'Stunned',\n                type: 'stun',\n                icon: '‚≠ê',\n                description: 'Unable to act',\n                duration: 2000,\n                intensity: 1,\n                effects: [],\n                stackable: false\n              }],\n              targeting: 'aoe',\n              animation: 'meteor_storm',\n              soundEffect: 'apocalypse',\n              description: 'Rains meteors from the sky',\n              telegraphTime: 3000,\n              interruptible: true\n            }\n          ],\n          mechanics: [\n            {\n              id: 'enrage',\n              type: 'enrage',\n              trigger: 'time',\n              triggerValue: 300000, // 5 minutes\n              effect: { damageMultiplier: 2.0, speedMultiplier: 1.5 },\n              description: 'Becomes enraged after 5 minutes'\n            }\n          ],\n          phaseTransition: {\n            animation: 'dragon_roar',\n            invulnerable: true,\n            duration: 3000,\n            effects: [{\n              id: 'fear',\n              name: 'Terrifying Presence',\n              type: 'debuff',\n              icon: 'üò±',\n              description: 'Paralyzed with fear',\n              duration: 2000,\n              intensity: 1,\n              effects: [],\n              stackable: false\n            }]\n          }\n        },\n        {\n          id: 'phase3',\n          name: 'Final Desperation',\n          healthThreshold: 0.2,\n          abilities: [\n            {\n              id: 'world_ender',\n              name: 'World Ender',\n              type: 'ultimate',\n              damage: 1000,\n              range: 500,\n              cooldown: 20000,\n              castTime: 6000,\n              manaCost: 0,\n              effects: [],\n              targeting: 'aoe',\n              animation: 'world_ender',\n              soundEffect: 'world_destruction',\n              description: 'An attack that can end the world itself',\n              telegraphTime: 5000,\n              interruptible: true\n            }\n          ],\n          mechanics: [\n            {\n              id: 'desperate_healing',\n              type: 'heal',\n              trigger: 'health',\n              triggerValue: 0.1,\n              effect: { healAmount: 2000 },\n              description: 'Heals when near death'\n            }\n          ]\n        }\n      ],\n      currentPhase: 0,\n      abilities: [],\n      statusEffects: [],\n      lastAbilityUse: 0,\n      enraged: false,\n      phaseTransitioning: false\n    };\n    \n    this.activeBosses.set('ancient_dragon', dragonBoss);\n  }\n  \n  private initializeCombatZones(): void {\n    // Dragon's Lair Combat Zone\n    const dragonLair: CombatZone = {\n      id: 'dragon_lair',\n      name: 'Ancient Dragon\\'s Lair',\n      bounds: { x: 0, y: 0, width: 500, height: 500 },\n      hazards: [\n        {\n          id: 'lava_pools',\n          type: 'environmental',\n          damage: 100,\n          interval: 1000,\n          areas: [\n            { x: 100, y: 100, radius: 50 },\n            { x: 300, y: 200, radius: 40 },\n            { x: 200, y: 350, radius: 60 }\n          ]\n        }\n      ],\n      buffs: [],\n      music: 'epic_boss_battle',\n      ambientEffects: ['dragon_roars', 'lava_bubbling', 'cave_echoes']\n    };\n    \n    this.combatZones.set('dragon_lair', dragonLair);\n  }\n  \n  // Main combat execution\n  performAttack(attackerId: string, targetId: string, weaponId: string): CombatResult | null {\n    const attacker = this.combatants.get(attackerId);\n    const target = this.combatants.get(targetId);\n    \n    if (!attacker || !target) return null;\n    \n    // Calculate damage\n    const damageCalc = this.calculateDamage(attacker, target, weaponId);\n    \n    // Apply damage\n    const actualDamage = this.applyDamage(targetId, damageCalc.finalDamage, damageCalc.damageType);\n    \n    // Create combat result\n    const result: CombatResult = {\n      damage: actualDamage,\n      critical: damageCalc.criticalHit,\n      blocked: false,\n      dodged: false,\n      effects: [],\n      message: this.generateCombatMessage(attacker, target, actualDamage, damageCalc.criticalHit)\n    };\n    \n    // Log combat event\n    this.logCombatEvent({\n      id: `attack_${Date.now()}`,\n      type: 'damage',\n      timestamp: Date.now(),\n      source: attackerId,\n      target: targetId,\n      value: actualDamage,\n      data: { weapon: weaponId, critical: damageCalc.criticalHit }\n    });\n    \n    // Check for boss phase transitions\n    if (this.activeBosses.has(targetId)) {\n      this.checkBossPhaseTransition(targetId);\n    }\n    \n    return result;\n  }\n  \n  private calculateDamage(attacker: CombatEntity, target: CombatEntity, weaponId: string): DamageCalculation {\n    // Base damage calculation\n    let baseDamage = attacker.stats.attack;\n    \n    // Weapon damage bonus\n    const weaponDamage = this.getWeaponDamage(weaponId);\n    baseDamage += weaponDamage.damage;\n    \n    // Apply damage variance\n    const variance = 1 + (Math.random() - 0.5) * this.damageVariance * 2;\n    baseDamage *= variance;\n    \n    // Critical hit calculation\n    const critChance = attacker.stats.criticalChance || this.criticalChance;\n    const criticalHit = Math.random() < critChance;\n    const critMultiplier = criticalHit ? (attacker.stats.criticalDamage || this.criticalMultiplier) : 1;\n    \n    // Apply critical multiplier\n    const criticalDamage = baseDamage * critMultiplier;\n    \n    // Calculate damage reduction\n    const defense = target.stats.defense || 0;\n    const damageReduction = defense / (defense + 100); // Diminishing returns formula\n    \n    // Apply resistances\n    const damageType = weaponDamage.type || 'physical';\n    const resistance = target.resistances?.[damageType] || 0;\n    const vulnerability = target.vulnerabilities?.[damageType] || 0;\n    const resistanceMultiplier = Math.max(0, 1 - resistance + vulnerability);\n    \n    // Final damage calculation\n    const finalDamage = Math.max(1, Math.floor(criticalDamage * (1 - damageReduction) * resistanceMultiplier));\n    \n    return {\n      baseDamage,\n      criticalHit,\n      criticalMultiplier: critMultiplier,\n      damageReduction,\n      finalDamage,\n      damageType: damageType as any,\n      resistances: target.resistances || {},\n      vulnerabilities: target.vulnerabilities || {}\n    };\n  }\n  \n  private getWeaponDamage(weaponId: string): { damage: number; type: string } {\n    const weapons: Record<string, { damage: number; type: string }> = {\n      fists: { damage: 10, type: 'physical' },\n      iron_sword: { damage: 50, type: 'physical' },\n      fire_sword: { damage: 70, type: 'fire' },\n      ice_staff: { damage: 60, type: 'ice' },\n      lightning_bow: { damage: 65, type: 'lightning' },\n      legendary_blade: { damage: 150, type: 'physical' },\n      mythical_staff: { damage: 200, type: 'magical' }\n    };\n    \n    return weapons[weaponId] || weapons.fists;\n  }\n  \n  private applyDamage(targetId: string, damage: number, damageType: string): number {\n    const target = this.combatants.get(targetId);\n    if (!target) return 0;\n    \n    // Apply damage\n    const actualDamage = Math.min(damage, target.stats.health);\n    target.stats.health -= actualDamage;\n    \n    // Check for death\n    if (target.stats.health <= 0) {\n      this.handleEntityDeath(targetId);\n    }\n    \n    return actualDamage;\n  }\n  \n  private handleEntityDeath(entityId: string): void {\n    const entity = this.combatants.get(entityId);\n    if (!entity) return;\n    \n    // Log death event\n    this.logCombatEvent({\n      id: `death_${Date.now()}`,\n      type: 'death',\n      timestamp: Date.now(),\n      source: '',\n      target: entityId,\n      value: 0,\n      data: { entityType: entity.type }\n    });\n    \n    // Handle boss death\n    if (this.activeBosses.has(entityId)) {\n      this.handleBossDeath(entityId);\n    }\n    \n    // Remove from combat\n    this.combatants.delete(entityId);\n    this.statusEffects.delete(entityId);\n  }\n  \n  private handleBossDeath(bossId: string): void {\n    const boss = this.activeBosses.get(bossId);\n    if (!boss) return;\n    \n    // Epic death sequence\n    this.triggerBossDeathSequence(boss);\n    \n    // Award legendary loot\n    this.awardBossLoot(boss);\n    \n    // Remove boss\n    this.activeBosses.delete(bossId);\n  }\n  \n  private triggerBossDeathSequence(boss: BossData): void {\n    // Epic visual effects, screen shake, particles, etc.\n    console.log(`${boss.name} has been defeated! Epic death sequence triggered.`);\n  }\n  \n  private awardBossLoot(boss: BossData): void {\n    const legendaryLoot = [\n      'dragon_scale_armor',\n      'flame_of_eternity',\n      'ancient_dragon_soul',\n      'pyraxis_crown',\n      'legendary_fire_gem'\n    ];\n    \n    console.log(`Legendary loot awarded: ${legendaryLoot.join(', ')}`);\n  }\n  \n  // Boss combat mechanics\n  private checkBossPhaseTransition(bossId: string): void {\n    const boss = this.activeBosses.get(bossId);\n    if (!boss || boss.phaseTransitioning) return;\n    \n    const healthPercent = boss.currentHealth / boss.maxHealth;\n    const currentPhase = boss.phases[boss.currentPhase];\n    \n    // Check if we should transition to next phase\n    if (boss.currentPhase < boss.phases.length - 1) {\n      const nextPhase = boss.phases[boss.currentPhase + 1];\n      if (healthPercent <= nextPhase.healthThreshold) {\n        this.triggerPhaseTransition(bossId, boss.currentPhase + 1);\n      }\n    }\n  }\n  \n  private triggerPhaseTransition(bossId: string, newPhaseIndex: number): void {\n    const boss = this.activeBosses.get(bossId);\n    if (!boss) return;\n    \n    const newPhase = boss.phases[newPhaseIndex];\n    if (!newPhase) return;\n    \n    boss.phaseTransitioning = true;\n    boss.currentPhase = newPhaseIndex;\n    \n    console.log(`${boss.name} transitions to ${newPhase.name}!`);\n    \n    // Apply phase transition effects\n    if (newPhase.phaseTransition) {\n      // Make boss invulnerable during transition\n      if (newPhase.phaseTransition.invulnerable) {\n        // Add invulnerability status\n      }\n      \n      // Apply transition effects to players\n      if (newPhase.phaseTransition.effects) {\n        // Apply effects to all players in combat\n      }\n      \n      // End transition after duration\n      setTimeout(() => {\n        boss.phaseTransitioning = false;\n      }, newPhase.phaseTransition.duration);\n    } else {\n      boss.phaseTransitioning = false;\n    }\n  }\n  \n  // Boss AI and ability usage\n  updateBossAI(bossId: string, deltaTime: number): void {\n    const boss = this.activeBosses.get(bossId);\n    if (!boss || boss.phaseTransitioning) return;\n    \n    const currentPhase = boss.phases[boss.currentPhase];\n    if (!currentPhase) return;\n    \n    // Check for ability usage\n    const now = Date.now();\n    for (const ability of currentPhase.abilities) {\n      if (now - boss.lastAbilityUse >= ability.cooldown) {\n        if (this.shouldUseAbility(boss, ability)) {\n          this.useBossAbility(bossId, ability);\n          boss.lastAbilityUse = now;\n          break; // Use one ability per update\n        }\n      }\n    }\n    \n    // Check mechanics\n    for (const mechanic of currentPhase.mechanics) {\n      this.checkBossMechanic(bossId, mechanic);\n    }\n  }\n  \n  private shouldUseAbility(boss: BossData, ability: BossAbility): boolean {\n    // AI logic to determine if boss should use this ability\n    // Consider player positions, boss health, ability priority, etc.\n    \n    switch (ability.type) {\n      case 'ultimate':\n        return boss.currentHealth / boss.maxHealth < 0.3; // Use ultimates when low health\n      case 'attack':\n        return Math.random() < 0.7; // 70% chance to use regular attacks\n      case 'spell':\n        return Math.random() < 0.5; // 50% chance to use spells\n      default:\n        return Math.random() < 0.6;\n    }\n  }\n  \n  private useBossAbility(bossId: string, ability: BossAbility): void {\n    console.log(`${bossId} uses ${ability.name}!`);\n    \n    // Telegraph the ability (warning phase)\n    if (ability.telegraphTime > 0) {\n      setTimeout(() => {\n        this.executeBossAbility(bossId, ability);\n      }, ability.telegraphTime);\n    } else {\n      this.executeBossAbility(bossId, ability);\n    }\n  }\n  \n  private executeBossAbility(bossId: string, ability: BossAbility): void {\n    // Execute the actual ability effect\n    switch (ability.targeting) {\n      case 'single':\n        // Target single player\n        break;\n      case 'aoe':\n        // Area of effect damage\n        break;\n      case 'cone':\n        // Cone-shaped attack\n        break;\n      case 'line':\n        // Line attack\n        break;\n      case 'random':\n        // Random targeting\n        break;\n    }\n    \n    // Apply ability effects\n    for (const effect of ability.effects) {\n      // Apply status effects to targets\n    }\n  }\n  \n  private checkBossMechanic(bossId: string, mechanic: BossMechanic): void {\n    const boss = this.activeBosses.get(bossId);\n    if (!boss) return;\n    \n    let shouldTrigger = false;\n    \n    switch (mechanic.trigger) {\n      case 'health':\n        const healthPercent = boss.currentHealth / boss.maxHealth;\n        shouldTrigger = healthPercent <= mechanic.triggerValue;\n        break;\n      case 'time':\n        shouldTrigger = this.combatTimer >= mechanic.triggerValue;\n        break;\n      // Add other trigger types\n    }\n    \n    if (shouldTrigger) {\n      this.executeBossMechanic(bossId, mechanic);\n    }\n  }\n  \n  private executeBossMechanic(bossId: string, mechanic: BossMechanic): void {\n    console.log(`Boss mechanic triggered: ${mechanic.type}`);\n    \n    switch (mechanic.type) {\n      case 'enrage':\n        const boss = this.activeBosses.get(bossId);\n        if (boss) {\n          boss.enraged = true;\n          // Apply enrage effects\n        }\n        break;\n      case 'heal':\n        // Boss healing mechanic\n        break;\n      case 'summon_adds':\n        // Summon additional enemies\n        break;\n      // Add other mechanic types\n    }\n  }\n  \n  // Status effect system\n  applyStatusEffect(targetId: string, effect: StatusEffect): void {\n    if (!this.statusEffects.has(targetId)) {\n      this.statusEffects.set(targetId, []);\n    }\n    \n    const effects = this.statusEffects.get(targetId)!;\n    \n    // Check if effect is stackable\n    if (effect.stackable) {\n      const existingEffect = effects.find(e => e.id === effect.id);\n      if (existingEffect && existingEffect.maxStacks) {\n        const currentStacks = effects.filter(e => e.id === effect.id).length;\n        if (currentStacks < existingEffect.maxStacks) {\n          effects.push({ ...effect });\n        }\n      } else {\n        effects.push({ ...effect });\n      }\n    } else {\n      // Remove existing effect of same type\n      const index = effects.findIndex(e => e.id === effect.id);\n      if (index >= 0) {\n        effects[index] = { ...effect };\n      } else {\n        effects.push({ ...effect });\n      }\n    }\n  }\n  \n  updateStatusEffects(deltaTime: number): void {\n    for (const [entityId, effects] of this.statusEffects.entries()) {\n      for (let i = effects.length - 1; i >= 0; i--) {\n        const effect = effects[i];\n        \n        // Update duration\n        effect.duration -= deltaTime;\n        \n        // Apply effect tick (for DOT/HOT effects)\n        if (effect.tickDamage && effect.duration > 0) {\n          this.applyDamage(entityId, effect.tickDamage, 'poison'); // Example damage type\n        }\n        \n        // Remove expired effects\n        if (effect.duration <= 0) {\n          effects.splice(i, 1);\n        }\n      }\n    }\n  }\n  \n  // Utility methods\n  private generateCombatMessage(attacker: CombatEntity, target: CombatEntity, damage: number, critical: boolean): string {\n    const critText = critical ? ' critically' : '';\n    return `${attacker.name}${critText} hits ${target.name} for ${damage} damage!`;\n  }\n  \n  private logCombatEvent(event: CombatEvent): void {\n    this.combatEvents.push(event);\n    \n    // Keep only recent events to manage memory\n    if (this.combatEvents.length > 1000) {\n      this.combatEvents = this.combatEvents.slice(-500);\n    }\n  }\n  \n  // Public API\n  addCombatant(id: string, entity: CombatEntity): void {\n    this.combatants.set(id, entity);\n  }\n  \n  removeCombatant(id: string): void {\n    this.combatants.delete(id);\n    this.statusEffects.delete(id);\n  }\n  \n  getCombatant(id: string): CombatEntity | undefined {\n    return this.combatants.get(id);\n  }\n  \n  getStatusEffects(entityId: string): StatusEffect[] {\n    return this.statusEffects.get(entityId) || [];\n  }\n  \n  getCombatEvents(): CombatEvent[] {\n    return [...this.combatEvents];\n  }\n  \n  getBoss(bossId: string): BossData | undefined {\n    return this.activeBosses.get(bossId);\n  }\n  \n  startBossEncounter(bossId: string): void {\n    const boss = this.activeBosses.get(bossId);\n    if (boss) {\n      this.combatActive = true;\n      console.log(`Epic boss encounter started: ${boss.name}!`);\n    }\n  }\n  \n  update(deltaTime: number): void {\n    this.combatTimer += deltaTime;\n    \n    // Update status effects\n    this.updateStatusEffects(deltaTime);\n    \n    // Update boss AI\n    for (const bossId of this.activeBosses.keys()) {\n      this.updateBossAI(bossId, deltaTime);\n    }\n  }\n}\n\n// Supporting interfaces\ninterface CombatEntity {\n  id: string;\n  name: string;\n  type: 'player' | 'enemy' | 'boss' | 'npc';\n  level: number;\n  stats: {\n    health: number;\n    maxHealth: number;\n    mana: number;\n    maxMana: number;\n    attack: number;\n    defense: number;\n    speed: number;\n    criticalChance?: number;\n    criticalDamage?: number;\n  };\n  resistances?: Record<string, number>;\n  vulnerabilities?: Record<string, number>;\n}\n\ninterface BossData {\n  id: string;\n  name: string;\n  level: number;\n  maxHealth: number;\n  currentHealth: number;\n  phases: BossPhase[];\n  currentPhase: number;\n  abilities: BossAbility[];\n  statusEffects: StatusEffect[];\n  lastAbilityUse: number;\n  enraged: boolean;\n  phaseTransitioning: boolean;\n}\n\ninterface CombatZone {\n  id: string;\n  name: string;\n  bounds: { x: number; y: number; width: number; height: number };\n  hazards: EnvironmentalHazard[];\n  buffs: ZoneBuff[];\n  music: string;\n  ambientEffects: string[];\n}\n\ninterface EnvironmentalHazard {\n  id: string;\n  type: 'environmental';\n  damage: number;\n  interval: number;\n  areas: { x: number; y: number; radius: number }[];\n}\n\ninterface ZoneBuff {\n  id: string;\n  name: string;\n  effect: StatusEffect;\n  area: { x: number; y: number; radius: number };\n}